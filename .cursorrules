# REGRAS DE DESENVOLVIMENTO - INSTA POST

Este documento contÃ©m instruÃ§Ãµes e princÃ­pios que devem ser seguidos SEMPRE durante o desenvolvimento do projeto Insta Post. Baseado em Clean Code, princÃ­pios de Martin Fowler e melhores prÃ¡ticas de desenvolvimento de software.

---

## ğŸ¯ OBJETIVO

Garantir que todo cÃ³digo produzido seja:
- **Limpo e legÃ­vel**
- **ManutenÃ­vel e escalÃ¡vel**
- **Bem estruturado**
- **TestÃ¡vel**
- **Seguindo padrÃµes estabelecidos**

---

## ğŸ“š PRINCÃPIOS FUNDAMENTAIS

### SOLID

1. **S - Single Responsibility Principle (SRP)**
   - Cada classe/funÃ§Ã£o deve ter uma Ãºnica razÃ£o para mudar
   - Uma classe deve fazer apenas uma coisa e fazer bem
   - Se uma funÃ§Ã£o faz mais de uma coisa, quebrar em funÃ§Ãµes menores

2. **O - Open/Closed Principle (OCP)**
   - Classes devem estar abertas para extensÃ£o, fechadas para modificaÃ§Ã£o
   - Use interfaces e abstraÃ§Ãµes para permitir extensÃ£o sem modificar cÃ³digo existente

3. **L - Liskov Substitution Principle (LSP)**
   - Objetos de uma superclasse devem ser substituÃ­veis por objetos de suas subclasses
   - Mantenha contratos consistentes

4. **I - Interface Segregation Principle (ISP)**
   - Muitas interfaces especÃ­ficas sÃ£o melhores que uma interface geral
   - Clientes nÃ£o devem depender de mÃ©todos que nÃ£o usam

5. **D - Dependency Inversion Principle (DIP)**
   - Dependa de abstraÃ§Ãµes, nÃ£o de concretizaÃ§Ãµes
   - MÃ³dulos de alto nÃ­vel nÃ£o devem depender de mÃ³dulos de baixo nÃ­vel

### Outros PrincÃ­pios Essenciais

- **D.R.Y. (Don't Repeat Yourself)**: Elimine duplicaÃ§Ã£o de cÃ³digo
- **K.I.S.S. (Keep It Simple, Stupid)**: A soluÃ§Ã£o mais simples Ã© geralmente a melhor
- **Y.A.G.N.I. (You Aren't Gonna Need It)**: NÃ£o implemente funcionalidades que nÃ£o sÃ£o necessÃ¡rias agora
- **Separation of Concerns**: Separe responsabilidades claramente

---

## ğŸ—ï¸ ARQUITETURA E ORGANIZAÃ‡ÃƒO

### Estrutura de Pastas (Feature-Based)

```
src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ domain/          # Entidades, tipos, regras de negÃ³cio
â”‚   â”‚   â”œâ”€â”€ application/     # Casos de uso, serviÃ§os
â”‚   â”‚   â”œâ”€â”€ infrastructure/  # ImplementaÃ§Ãµes (repositÃ³rios, APIs externas)
â”‚   â”‚   â””â”€â”€ presentation/    # Controllers, DTOs, validaÃ§Ãµes
â”‚   â”œâ”€â”€ posts/
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â””â”€â”€ presentation/
â”‚   â””â”€â”€ subscriptions/
â”‚       â””â”€â”€ ...
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ types/               # Tipos compartilhados
â”‚   â”œâ”€â”€ utils/               # UtilitÃ¡rios genÃ©ricos
â”‚   â”œâ”€â”€ errors/              # Erros customizados
â”‚   â””â”€â”€ constants/           # Constantes
â””â”€â”€ lib/                     # Bibliotecas/configuraÃ§Ãµes externas
```

### Camadas (Clean Architecture)

1. **Domain Layer (NÃºcleo)**
   - Entidades de negÃ³cio
   - Regras de negÃ³cio puras
   - Interfaces de repositÃ³rios
   - **NÃƒO depende de nada externo**

2. **Application Layer (Casos de Uso)**
   - Orquestra a lÃ³gica de negÃ³cio
   - Define interfaces de serviÃ§os
   - Depende apenas do Domain

3. **Infrastructure Layer (ImplementaÃ§Ãµes)**
   - ImplementaÃ§Ãµes de repositÃ³rios
   - IntegraÃ§Ãµes com APIs externas
   - Acesso a banco de dados
   - Depende de Application e Domain

4. **Presentation Layer (Interface)**
   - Controllers/Endpoints
   - DTOs
   - ValidaÃ§Ãµes de entrada
   - Depende de Application

---

## ğŸ“ CONVENÃ‡Ã•ES DE CÃ“DIGO

### Nomenclatura

- **Classes**: PascalCase (`UserService`, `PostRepository`)
- **FunÃ§Ãµes/MÃ©todos**: camelCase (`createPost`, `calculateCredits`)
- **Constantes**: UPPER_SNAKE_CASE (`MAX_RETRY_ATTEMPTS`, `DEFAULT_PAGE_SIZE`)
- **Interfaces/Types**: PascalCase com prefixo `I` opcional (`IUserRepository`, `PostDTO`)
- **Arquivos**: kebab-case (`user-service.ts`, `post-repository.ts`)
- **VariÃ¡veis privadas**: Preferir TypeScript `private` em vez de `_` prefix

### FunÃ§Ãµes e MÃ©todos

**Regras:**
- FunÃ§Ãµes devem ser pequenas (idealmente < 20 linhas)
- Um nÃ­vel de abstraÃ§Ã£o por funÃ§Ã£o
- Nomes descritivos que revelam intenÃ§Ã£o
- No mÃ¡ximo 3-4 parÃ¢metros (preferir objetos para mais parÃ¢metros)
- Sem efeitos colaterais inesperados
- Retornar valores especÃ­ficos, nÃ£o `any`

### Classes

**Regras:**
- Uma responsabilidade por classe
- Pequenas (quanto menor, melhor)
- CoesÃ£o alta (mÃ©todos relacionados)
- Acoplamento baixo (poucas dependÃªncias)
- Use injeÃ§Ã£o de dependÃªncia

### Tipos e Interfaces

**Regras:**
- Evite `any` - use tipos especÃ­ficos ou `unknown`
- Prefira interfaces para objetos
- Use types para unions, intersections, primitives
- ValidaÃ§Ã£o de tipos em runtime com Zod (na camada de apresentaÃ§Ã£o)

---

## ğŸ”„ REFACTORING (Martin Fowler)

### Code Smells Comuns - Identificar e Corrigir

1. **Long Method** - Quebrar em mÃ©todos menores
2. **Large Class** - Dividir responsabilidades
3. **Duplicated Code** - Extrair para funÃ§Ã£o/comum
4. **Long Parameter List** - Usar objetos de parÃ¢metros
5. **Feature Envy** - Mover mÃ©todo para classe apropriada
6. **Data Clumps** - Agrupar dados relacionados em objetos
7. **Primitive Obsession** - Substituir primitivos por Value Objects quando fizer sentido

### Refactorings Frequentes

- Extract Method, Extract Class, Extract Variable
- Rename, Move Method/Field
- Replace Magic Number/String
- Introduce Parameter Object
- Replace Conditional with Polymorphism (quando apropriado)

---

## ğŸ§ª TESTES

### EstratÃ©gia

1. **Unit Tests** - FunÃ§Ãµes/mÃ©todos isoladamente com mocks
2. **Integration Tests** - IntegraÃ§Ãµes entre camadas
3. **E2E Tests** - Fluxos crÃ­ticos end-to-end (quando necessÃ¡rio)

### Boas PrÃ¡ticas

- Nomes descritivos: `should [aÃ§Ã£o] when [condiÃ§Ã£o]`
- Arrange-Act-Assert pattern
- Um conceito por teste
- Testes rÃ¡pidos e independentes
- Testar comportamento, nÃ£o implementaÃ§Ã£o

---

## ğŸ›¡ï¸ TRATAMENTO DE ERROS

**Regras:**
- Erros especÃ­ficos e nomeados
- Mensagens claras e informativas
- Hierarquia de erros quando necessÃ¡rio
- NÃ£o engolir erros silenciosamente
- Tratar erros no nÃ­vel apropriado
- Logar erros apropriadamente

---

## ğŸ”Œ INJEÃ‡ÃƒO DE DEPENDÃŠNCIAS

**Regras:**
- Sempre injetar dependÃªncias via constructor
- Depender de interfaces, nÃ£o implementaÃ§Ãµes
- Facilita testes (mocks/stubs)
- Facilita mudanÃ§as futuras

---

## ğŸ“¦ VALIDAÃ‡ÃƒO E DTOs

**Regras:**
- Validar na entrada (camada de apresentaÃ§Ã£o)
- Usar Zod para validaÃ§Ã£o e inferÃªncia de tipos
- DTOs explÃ­citos para entrada/saÃ­da
- NÃ£o confiar em dados externos

---

## ğŸ”„ ASSINCRONICIDADE

**Regras:**
- Prefira async/await sobre Promises encadeadas
- Use Promise.all para operaÃ§Ãµes paralelas
- Sempre trate erros
- Seja explÃ­cito com tipos de retorno

---

## ğŸ“Š LOGGING

**Regras:**
- Usar logger estruturado (Winston, Pino)
- NÃ­veis apropriados (debug, info, warn, error)
- Contexto Ãºtil (IDs, parÃ¢metros relevantes)
- NÃ£o logar informaÃ§Ãµes sensÃ­veis
- Logs em produÃ§Ã£o devem ser Ãºteis para debugging

---

## ğŸ¨ COMENTÃRIOS E DOCUMENTAÃ‡ÃƒO

**Regras:**
- CÃ³digo deve ser autoexplicativo
- ComentÃ¡rios devem explicar "por quÃª", nÃ£o "o quÃª"
- Use JSDoc para funÃ§Ãµes pÃºblicas/complexas
- Remova cÃ³digo comentado
- Documente decisÃµes arquiteturais importantes

---

## âš¡ PERFORMANCE

### PrincÃ­pios

1. **Premature Optimization Ã© ruim** - Otimize apenas quando necessÃ¡rio
2. **OtimizaÃ§Ãµes Comuns**: Queries eficientes, paginaÃ§Ã£o, cache, Promise.all
3. **Evitar**: N+1 queries, dados desnecessÃ¡rios, loops aninhados, operaÃ§Ãµes bloqueantes

---

## ğŸ”’ SEGURANÃ‡A

### PrincÃ­pios

1. **ValidaÃ§Ã£o de Input** - Sempre validar, sanitizar, usar Zod
2. **AutenticaÃ§Ã£o e AutorizaÃ§Ã£o** - Verificar em rotas protegidas, RLS no banco
3. **Dados SensÃ­veis** - Nunca logar senhas/tokens, usar variÃ¡veis de ambiente
4. **SQL Injection** - Usar Prisma (prevenÃ§Ã£o automÃ¡tica)

---

## ğŸ“ PADRÃ•ES DE PROJETO (Quando Apropriado)

- **Repository Pattern** - Para acesso a dados
- **Service Layer Pattern** - Para orquestrar lÃ³gica de negÃ³cio
- **Factory Pattern** - Quando necessÃ¡rio para criaÃ§Ã£o de objetos

---

## âœ… CHECKLIST DE REVISÃƒO

Antes de considerar cÃ³digo completo, verificar:

- [ ] CÃ³digo segue princÃ­pios SOLID?
- [ ] FunÃ§Ãµes sÃ£o pequenas e focadas?
- [ ] Nomes sÃ£o descritivos e revelam intenÃ§Ã£o?
- [ ] NÃ£o hÃ¡ duplicaÃ§Ã£o de cÃ³digo?
- [ ] DependÃªncias sÃ£o injetadas?
- [ ] Tipos sÃ£o explÃ­citos (sem `any` desnecessÃ¡rio)?
- [ ] Erros sÃ£o tratados adequadamente?
- [ ] ValidaÃ§Ãµes estÃ£o na camada apropriada?
- [ ] Logging estÃ¡ adequado?
- [ ] CÃ³digo estÃ¡ testado (quando aplicÃ¡vel)?
- [ ] ComentÃ¡rios explicam "por quÃª" quando necessÃ¡rio?
- [ ] CÃ³digo segue estrutura de pastas estabelecida?

---

## ğŸ¯ RESUMO EXECUTIVO

**Sempre:**
- Escreva cÃ³digo limpo e legÃ­vel
- Prefira cÃ³digo claro e explÃ­cito sobre cÃ³digo "esperto"
- Pequeno Ã© melhor que grande
- Simples Ã© melhor que complexo
- Leitura Ã© mais importante que escrita

**Nunca:**
- Otimize prematuramente
- Implemente funcionalidades que nÃ£o sÃ£o necessÃ¡rias
- Comprometa legibilidade por performance (a menos que realmente necessÃ¡rio)
- Ignore erros silenciosamente
- Use `any` sem necessidade real

---

**ReferÃªncias:**
- Clean Code (Robert C. Martin)
- Refactoring (Martin Fowler)
- Patterns of Enterprise Application Architecture (Martin Fowler)
- Domain-Driven Design (Eric Evans)
- TypeScript Handbook
- SOLID Principles
